// FICHIER: ./services/taskService.js

import { supabase } from './supabase';

export class TaskService {

  // ================================
  // GESTION DES T√ÇCHES CLASSIQUES
  // ================================

  // ‚úÖ R√©cup√©rer les t√¢ches du jour pour un utilisateur
  static async getTodayTasks(userId) {
    try {
      console.log('üìã R√©cup√©ration t√¢ches du jour...', { userId });
      
      const { data, error } = await supabase
        .from('tasks')
        .select('*')
        .eq('user_id', userId)
        .eq('status', 'current')
        .order('priority', { ascending: false })  // high, medium, low
        .order('created_at', { ascending: true });

      if (error) {
        throw error;
      }

      console.log(`‚úÖ ${data?.length || 0} t√¢ches trouv√©es`);
      return {
        success: true,
        tasks: data || []
      };

    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration t√¢ches:', error);
      return {
        success: false,
        error: error.message,
        tasks: []
      };
    }
  }

  // ‚úÖ R√©cup√©rer les t√¢ches termin√©es
  static async getCompletedTasks(userId, limit = 10) {
    try {
      console.log('‚úÖ R√©cup√©ration t√¢ches termin√©es...', { userId, limit });
      
      const { data, error } = await supabase
        .from('tasks')
        .select('*')
        .eq('user_id', userId)
        .eq('status', 'completed')
        .order('completed_at', { ascending: false })
        .limit(limit);

      if (error) {
        throw error;
      }

      console.log(`‚úÖ ${data?.length || 0} t√¢ches termin√©es trouv√©es`);
      return {
        success: true,
        tasks: data || []
      };

    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration t√¢ches termin√©es:', error);
      return {
        success: false,
        error: error.message,
        tasks: []
      };
    }
  }

  // ‚úÖ Cr√©er une nouvelle t√¢che
  static async createTask(userId, taskData) {
    try {
      console.log('üÜï Cr√©ation nouvelle t√¢che...', { userId, taskData });

      const newTask = {
        user_id: userId,
        title: taskData.title,
        description: taskData.description || null,
        category: taskData.category || 'personal',
        priority: taskData.priority || 'medium',
        progress: 0,
        estimated_time: taskData.estimatedTime || null,
        status: 'current'
      };

      const { data, error } = await supabase
        .from('tasks')
        .insert([newTask])
        .select()
        .single();

      if (error) {
        throw error;
      }

      console.log('‚úÖ T√¢che cr√©√©e:', data);
      return {
        success: true,
        task: data
      };

    } catch (error) {
      console.error('‚ùå Erreur cr√©ation t√¢che:', error);
      return {
        success: false,
        error: error.message,
        task: null
      };
    }
  }

  // ‚úÖ Mettre √† jour le progr√®s d'une t√¢che
  static async updateTaskProgress(taskId, progress) {
    try {
      console.log('üîÑ Mise √† jour progr√®s t√¢che...', { taskId, progress });

      const updates = {
        progress: Math.max(0, Math.min(100, progress)),
        updated_at: new Date().toISOString()
      };

      // Si la t√¢che atteint 100%, la marquer comme termin√©e
      if (progress >= 100) {
        updates.status = 'completed';
        updates.completed_at = new Date().toISOString();
      }

      const { data, error } = await supabase
        .from('tasks')
        .update(updates)
        .eq('id', taskId)
        .select()
        .single();

      if (error) {
        throw error;
      }

      console.log('‚úÖ Progr√®s mis √† jour:', data);
      return {
        success: true,
        task: data
      };

    } catch (error) {
      console.error('‚ùå Erreur mise √† jour progr√®s:', error);
      return {
        success: false,
        error: error.message,
        task: null
      };
    }
  }

  // ‚úÖ Marquer une t√¢che comme termin√©e
  static async completeTask(taskId) {
    try {
      console.log('‚úÖ Marquage t√¢che termin√©e...', { taskId });

      const { data, error } = await supabase
        .from('tasks')
        .update({
          status: 'completed',
          progress: 100,
          completed_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', taskId)
        .select()
        .single();

      if (error) {
        throw error;
      }

      console.log('‚úÖ T√¢che marqu√©e termin√©e:', data);
      return {
        success: true,
        task: data
      };

    } catch (error) {
      console.error('‚ùå Erreur completion t√¢che:', error);
      return {
        success: false,
        error: error.message,
        task: null
      };
    }
  }

  // ‚úÖ Restaurer une t√¢che termin√©e (la remettre en cours)
  static async restoreTask(taskId, newProgress = 75) {
    try {
      console.log('üîÑ Restauration t√¢che...', { taskId, newProgress });

      const { data, error } = await supabase
        .from('tasks')
        .update({
          status: 'current',
          progress: newProgress,
          completed_at: null,
          updated_at: new Date().toISOString()
        })
        .eq('id', taskId)
        .select()
        .single();

      if (error) {
        throw error;
      }

      console.log('‚úÖ T√¢che restaur√©e:', data);
      return {
        success: true,
        task: data
      };

    } catch (error) {
      console.error('‚ùå Erreur restauration t√¢che:', error);
      return {
        success: false,
        error: error.message,
        task: null
      };
    }
  }

  // ================================
  // GESTION DES MIT (Most Important Tasks)
  // ================================

  // ‚úÖ R√©cup√©rer les MIT actives d'un utilisateur
  static async getActiveMITs(userId) {
    try {
      console.log('‚ö° R√©cup√©ration MIT actives...', { userId });
      
      const today = new Date().toISOString().split('T')[0];
      
      const { data, error } = await supabase
        .from('mits')
        .select('*')
        .eq('user_id', userId)
        .eq('is_active', true)
        .lte('start_date', today)
        .or(`end_date.is.null,end_date.gte.${today}`)
        .order('priority', { ascending: false })
        .order('created_at', { ascending: true });

      if (error) {
        throw error;
      }

      console.log(`‚úÖ ${data?.length || 0} MIT actives trouv√©es`);
      console.log('üîç Exemple MIT avec is_recurring:', data?.[0]?.is_recurring);
      
      return {
        success: true,
        mits: data || []
      };

    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration MIT:', error);
      return {
        success: false,
        error: error.message,
        mits: []
      };
    }
  }

  // ‚úÖ CORRIG√â: Cr√©er une nouvelle MIT avec gestion is_recurring
  static async createMIT(userId, mitData) {
    try {
      console.log('‚ö° Cr√©ation nouvelle MIT...', { userId, mitData });
      console.log('üîß isRecurring re√ßu:', mitData.isRecurring, typeof mitData.isRecurring);

      const newMIT = {
        user_id: userId,
        text: mitData.text,
        priority: mitData.priority || 'medium',
        estimated_time: mitData.estimatedTime || null,
        is_recurring: Boolean(mitData.isRecurring), // ‚úÖ NOUVEAU: Conversion explicite en bool√©en
        start_date: mitData.startDate || new Date().toISOString().split('T')[0],
        end_date: mitData.endDate || null,
        is_active: true
      };

      console.log('üìù Donn√©es MIT √† ins√©rer:', newMIT);

      const { data, error } = await supabase
        .from('mits')
        .insert([newMIT])
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur Supabase createMIT:', error);
        throw error;
      }

      console.log('‚úÖ MIT cr√©√©e avec is_recurring:', data.is_recurring);
      return {
        success: true,
        mit: data
      };

    } catch (error) {
      console.error('‚ùå Erreur cr√©ation MIT:', error);
      return {
        success: false,
        error: error.message,
        mit: null
      };
    }
  }

  // ‚úÖ ANCIEN: Marquer une MIT comme termin√©e pour aujourd'hui (conserv√© pour compatibilit√©)
  static async completeMITToday(userId, mitId) {
    const today = new Date().toISOString().split('T')[0];
    return this.completeMITForDate(userId, mitId, today);
  }

  // ‚úÖ NOUVEAU: Marquer une MIT comme termin√©e pour une date sp√©cifique
  static async completeMITForDate(userId, mitId, targetDate) {
    try {
      console.log('‚úÖ Marquage MIT termin√©e pour date...', { userId, mitId, targetDate });

      // V√©rifier si d√©j√† marqu√©e comme termin√©e pour cette date
      const { data: existing } = await supabase
        .from('mit_completions')
        .select('id')
        .eq('user_id', userId)
        .eq('mit_id', mitId)
        .eq('date', targetDate)
        .single();

      if (existing) {
        console.log('‚ö†Ô∏è MIT d√©j√† marqu√©e termin√©e pour cette date');
        return {
          success: true,
          completion: existing,
          alreadyCompleted: true
        };
      }

      // Cr√©er la completion pour la date sp√©cifi√©e
      const { data, error } = await supabase
        .from('mit_completions')
        .insert([{
          user_id: userId,
          mit_id: mitId,
          date: targetDate,
          completed_at: new Date().toISOString()
        }])
        .select()
        .single();

      if (error) {
        throw error;
      }

      console.log(`‚úÖ MIT marqu√©e termin√©e pour ${targetDate}:`, data);
      return {
        success: true,
        completion: data,
        alreadyCompleted: false
      };

    } catch (error) {
      console.error('‚ùå Erreur completion MIT pour date:', error);
      return {
        success: false,
        error: error.message,
        completion: null
      };
    }
  }

  // ‚úÖ NOUVEAU: D√©cocher une MIT pour une date sp√©cifique
  static async uncompleteMITForDate(userId, mitId, targetDate) {
    try {
      console.log('‚Ü©Ô∏è D√©cocher MIT pour date...', { userId, mitId, targetDate });

      const { error } = await supabase
        .from('mit_completions')
        .delete()
        .eq('user_id', userId)
        .eq('mit_id', mitId)
        .eq('date', targetDate);

      if (error) {
        throw error;
      }

      console.log(`‚úÖ MIT d√©coch√©e pour ${targetDate}`);
      return {
        success: true
      };

    } catch (error) {
      console.error('‚ùå Erreur d√©cocher MIT:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // ‚úÖ V√©rifier si une MIT est termin√©e aujourd'hui
  static async isMITCompletedToday(userId, mitId) {
    try {
      const today = new Date().toISOString().split('T')[0];
      
      const { data, error } = await supabase
        .from('mit_completions')
        .select('id')
        .eq('user_id', userId)
        .eq('mit_id', mitId)
        .eq('date', today)
        .single();

      if (error && error.code !== 'PGRST116') {
        throw error;
      }

      return {
        success: true,
        isCompleted: !!data
      };

    } catch (error) {
      console.error('‚ùå Erreur v√©rification MIT:', error);
      return {
        success: false,
        error: error.message,
        isCompleted: false
      };
    }
  }

  // ================================
  // GESTION DES MET (Most Emotional Tasks)
  // ================================

  // ‚úÖ R√©cup√©rer les MET actives d'un utilisateur
  static async getActiveMETs(userId) {
    try {
      console.log('üö´ R√©cup√©ration MET actives...', { userId });
      
      const today = new Date().toISOString().split('T')[0];
      
      const { data, error } = await supabase
        .from('mets')
        .select('*')
        .eq('user_id', userId)
        .eq('is_active', true)
        .lte('start_date', today)
        .or(`end_date.is.null,end_date.gte.${today}`)
        .order('created_at', { ascending: true });

      if (error) {
        throw error;
      }

      console.log(`‚úÖ ${data?.length || 0} MET actives trouv√©es`);
      console.log('üîç Exemple MET avec is_recurring:', data?.[0]?.is_recurring);
      
      return {
        success: true,
        mets: data || []
      };

    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration MET:', error);
      return {
        success: false,
        error: error.message,
        mets: []
      };
    }
  }

  // ‚úÖ CORRIG√â: Cr√©er une nouvelle MET avec gestion is_recurring
  static async createMET(userId, metData) {
    try {
      console.log('üö´ Cr√©ation nouvelle MET...', { userId, metData });
      console.log('üîß isRecurring re√ßu:', metData.isRecurring, typeof metData.isRecurring);

      const newMET = {
        user_id: userId,
        text: metData.text,
        is_recurring: Boolean(metData.isRecurring), // ‚úÖ NOUVEAU: Conversion explicite en bool√©en
        start_date: metData.startDate || new Date().toISOString().split('T')[0],
        end_date: metData.endDate || null,
        is_active: true
      };

      console.log('üìù Donn√©es MET √† ins√©rer:', newMET);

      const { data, error } = await supabase
        .from('mets')
        .insert([newMET])
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur Supabase createMET:', error);
        throw error;
      }

      console.log('‚úÖ MET cr√©√©e avec is_recurring:', data.is_recurring);
      return {
        success: true,
        met: data
      };

    } catch (error) {
      console.error('‚ùå Erreur cr√©ation MET:', error);
      return {
        success: false,
        error: error.message,
        met: null
      };
    }
  }

  // ‚úÖ ANCIEN: Marquer une MET comme "faite" pour aujourd'hui (conserv√© pour compatibilit√©)
  static async checkMETToday(userId, metId) {
    const today = new Date().toISOString().split('T')[0];
    return this.checkMETForDate(userId, metId, today);
  }

  // ‚úÖ NOUVEAU: Marquer une MET comme "faite" pour une date sp√©cifique
  static async checkMETForDate(userId, metId, targetDate) {
    try {
      console.log('üö´ Marquage MET faite pour date...', { userId, metId, targetDate });

      // V√©rifier si d√©j√† marqu√©e pour cette date
      const { data: existing } = await supabase
        .from('met_checks')
        .select('id')
        .eq('user_id', userId)
        .eq('met_id', metId)
        .eq('date', targetDate)
        .single();

      if (existing) {
        console.log('‚ö†Ô∏è MET d√©j√† marqu√©e pour cette date');
        return {
          success: true,
          check: existing,
          alreadyChecked: true
        };
      }

      // Cr√©er le check pour la date sp√©cifi√©e
      const { data, error } = await supabase
        .from('met_checks')
        .insert([{
          user_id: userId,
          met_id: metId,
          date: targetDate,
          checked_at: new Date().toISOString()
        }])
        .select()
        .single();

      if (error) {
        throw error;
      }

      console.log(`‚úÖ MET marqu√©e faite pour ${targetDate}:`, data);
      return {
        success: true,
        check: data,
        alreadyChecked: false
      };

    } catch (error) {
      console.error('‚ùå Erreur check MET pour date:', error);
      return {
        success: false,
        error: error.message,
        check: null
      };
    }
  }

  // ‚úÖ NOUVEAU: D√©cocher une MET pour une date sp√©cifique
  static async uncheckMETForDate(userId, metId, targetDate) {
    try {
      console.log('‚Ü©Ô∏è D√©cocher MET pour date...', { userId, metId, targetDate });

      const { error } = await supabase
        .from('met_checks')
        .delete()
        .eq('user_id', userId)
        .eq('met_id', metId)
        .eq('date', targetDate);

      if (error) {
        throw error;
      }

      console.log(`‚úÖ MET d√©coch√©e pour ${targetDate}`);
      return {
        success: true
      };

    } catch (error) {
      console.error('‚ùå Erreur d√©cocher MET:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // ‚úÖ R√©cup√©rer les stats MIT/MET du jour
  static async getTodayMITMETStats(userId) {
    try {
      const today = new Date().toISOString().split('T')[0];
      
      console.log('üìä R√©cup√©ration stats MIT/MET du jour...', { userId, today });

      // R√©cup√©rer toutes les MIT actives
      const { mits } = await this.getActiveMITs(userId);
      
      // R√©cup√©rer toutes les MET actives
      const { mets } = await this.getActiveMETs(userId);

      // R√©cup√©rer les completions MIT du jour
      const { data: mitCompletions, error: mitError } = await supabase
        .from('mit_completions')
        .select('mit_id')
        .eq('user_id', userId)
        .eq('date', today);

      if (mitError) throw mitError;

      // R√©cup√©rer les checks MET du jour
      const { data: metChecks, error: metError } = await supabase
        .from('met_checks')
        .select('met_id')
        .eq('user_id', userId)
        .eq('date', today);

      if (metError) throw metError;

      const stats = {
        totalMITs: mits.length,
        completedMITs: mitCompletions?.length || 0,
        totalMETs: mets.length,
        checkedMETs: metChecks?.length || 0,
        mitCompletionRate: mits.length > 0 ? (mitCompletions?.length || 0) / mits.length : 0,
        metAvoidanceRate: mets.length > 0 ? 1 - ((metChecks?.length || 0) / mets.length) : 1,
        // ‚úÖ NOUVEAU: Stats pour les t√¢ches r√©currentes
        recurringMITs: mits.filter(mit => mit.is_recurring).length,
        recurringMETs: mets.filter(met => met.is_recurring).length
      };

      console.log('‚úÖ Stats MIT/MET calcul√©es:', stats);
      return {
        success: true,
        stats
      };

    } catch (error) {
      console.error('‚ùå Erreur stats MIT/MET:', error);
      return {
        success: false,
        error: error.message,
        stats: null
      };
    }
  }

  // ‚úÖ R√©cup√©rer les t√¢ches avec filtres
  static async getTasksWithFilters(userId, filters = {}) {
    try {
      let query = supabase
        .from('tasks')
        .select('*')
        .eq('user_id', userId);

      // Appliquer les filtres
      if (filters.status) {
        query = query.eq('status', filters.status);
      }
      
      if (filters.category) {
        query = query.eq('category', filters.category);
      }
      
      if (filters.priority) {
        query = query.eq('priority', filters.priority);
      }

      // Tri
      if (filters.orderBy) {
        query = query.order(filters.orderBy, { 
          ascending: filters.ascending !== false 
        });
      } else {
        query = query.order('created_at', { ascending: false });
      }

      // Limite
      if (filters.limit) {
        query = query.limit(filters.limit);
      }

      const { data, error } = await query;

      if (error) {
        throw error;
      }

      console.log(`‚úÖ ${data?.length || 0} t√¢ches r√©cup√©r√©es avec filtres:`, filters);
      return {
        success: true,
        tasks: data || []
      };

    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration t√¢ches filtr√©es:', error);
      return {
        success: false,
        error: error.message,
        tasks: []
      };
    }
  }

  // ‚úÖ NOUVEAU: R√©cup√©rer les MIT/MET r√©currentes pour mise √† jour automatique
  static async getRecurringTasks(userId) {
    try {
      console.log('üîÑ R√©cup√©ration t√¢ches r√©currentes...', { userId });

      const [mitsResult, metsResult] = await Promise.all([
        supabase
          .from('mits')
          .select('*')
          .eq('user_id', userId)
          .eq('is_active', true)
          .eq('is_recurring', true),
        
        supabase
          .from('mets')
          .select('*')
          .eq('user_id', userId)
          .eq('is_active', true)
          .eq('is_recurring', true)
      ]);

      if (mitsResult.error) throw mitsResult.error;
      if (metsResult.error) throw metsResult.error;

      const recurringTasks = {
        mits: mitsResult.data || [],
        mets: metsResult.data || []
      };

      console.log('‚úÖ T√¢ches r√©currentes trouv√©es:', {
        mits: recurringTasks.mits.length,
        mets: recurringTasks.mets.length
      });

      return {
        success: true,
        recurringTasks
      };

    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration t√¢ches r√©currentes:', error);
      return {
        success: false,
        error: error.message,
        recurringTasks: { mits: [], mets: [] }
      };
    }
  }

  // ‚úÖ NOUVEAU: R√©cup√©rer les completions/checks pour une date sp√©cifique
  static async getTaskDataForDate(userId, targetDate) {
    try {
      console.log('üìÖ R√©cup√©ration donn√©es t√¢ches pour date...', { userId, targetDate });

      const [mitCompletions, metChecks] = await Promise.all([
        supabase
          .from('mit_completions')
          .select('mit_id')
          .eq('user_id', userId)
          .eq('date', targetDate),
        
        supabase
          .from('met_checks')
          .select('met_id')
          .eq('user_id', userId)
          .eq('date', targetDate)
      ]);

      if (mitCompletions.error) throw mitCompletions.error;
      if (metChecks.error) throw metChecks.error;

      return {
        success: true,
        mitCompletions: mitCompletions.data?.map(c => c.mit_id) || [],
        metChecks: metChecks.data?.map(c => c.met_id) || []
      };

    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration donn√©es date:', error);
      return {
        success: false,
        error: error.message,
        mitCompletions: [],
        metChecks: []
      };
    }
  }
}